@page "/battleship"
@inject BlazorApp1.Services.GameStateService GameState
@inject NavigationManager Navigation

<div class="battle-container">
    <!-- Animated background particles -->
    <div class="particles-bg">
        @for (int i = 0; i < 40; i++)
        {
            <div class="particle" style="--delay: @(i * 0.12)s; --duration: @(Random.Shared.Next(5, 12))s;"></div>
        }
    </div>

    <div class="battle-content">
        <h3 @onclick="NavigateToHome" style="cursor: pointer;">Command Your Fleet</h3>

        <div class="boards-container">
    <div class="board-section">
        <table>
            @for (int row = 0; row < 10; row++)
            {
                <tr>
                    @for (int col = 0; col < 10; col++)
                    {
                        int currentRow = row;
                        int currentCol = col;
                        <td class="@GetPlayerCellClass(currentRow, currentCol)">
                            @DisplayPlayerCellContent(currentRow, currentCol)
                        </td>
                    }
                </tr>
            }
        </table>
        <div class="board-label @(isPlayerTurn ? "" : "active-turn") @(CheckVictory() || CheckDefeat() ? "hidden" : "")">
            <h3>Your Fleet</h3>
        </div>
    </div>
    
    <div class="board-section">
        <table>
            @for (int row = 0; row < 10; row++)
            {
                <tr>
                    @for (int col = 0; col < 10; col++)
                    {
                        int currentRow = row;
                        int currentCol = col;
                        <td class="@GetOpponentCellClass(currentRow, currentCol)" 
                            @onclick="() => OnOpponentCellClick(currentRow, currentCol)">
                            @DisplayCellContent(opponentGrid, currentRow, currentCol)
                        </td>
                    }
                </tr>
            }
        </table>
        <div class="board-label @(isPlayerTurn ? "active-turn" : "") @(CheckVictory() || CheckDefeat() ? "hidden" : "")">
            <h3>Enemy Waters</h3>
        </div>
    </div>
</div>

        @if (CheckVictory() || CheckDefeat())
        {
            <div class="game-result-overlay">
                @if (CheckVictory())
                {
                    <h2 class="result-text victory-text">Victory</h2>
                }
                else
                {
                    <h2 class="result-text defeat-text">Defeat</h2>
                }
            </div>
            
            <div class="game-over-controls">
                <button class="btn btn-orange play-again-btn" @onclick="RestartGame">Play Again</button>
                <button class="btn btn-home home-btn" @onclick="NavigateToHome">Home</button>
            </div>
        }
    </div>
</div>

@foreach (var explosion in activeExplosions)
{
    <!-- First mini explosion (top/center) - Fire colors -->
    <div class="mini-explosion explosion-1" style="top: @(GetExplosionTop(explosion) - 2)%; left: @(GetExplosionLeft(explosion))%;">
        <div class="mini-explosion-ring fire-ring"></div>
        <div class="mini-explosion-ring fire-ring"></div>
        <div class="mini-explosion-particles">
            <div class="mini-particle-spark fire-spark"></div>
            <div class="mini-particle-spark fire-spark"></div>
            <div class="mini-particle-spark fire-spark"></div>
            <div class="mini-particle-spark fire-spark"></div>
        </div>
    </div>
    
    <!-- Second mini explosion (left) - Transition colors -->
    <div class="mini-explosion explosion-2" style="top: @(GetExplosionTop(explosion) + 1)%; left: @(GetExplosionLeft(explosion) - 3)%;">
        <div class="mini-explosion-ring transition-ring"></div>
        <div class="mini-explosion-ring transition-ring"></div>
        <div class="mini-explosion-particles">
            <div class="mini-particle-spark transition-spark"></div>
            <div class="mini-particle-spark transition-spark"></div>
            <div class="mini-particle-spark transition-spark"></div>
            <div class="mini-particle-spark transition-spark"></div>
        </div>
    </div>
    
    <!-- Third mini explosion (right) - Water/sinking colors -->
    <div class="mini-explosion explosion-3" style="top: @(GetExplosionTop(explosion) + 1)%; left: @(GetExplosionLeft(explosion) + 3)%;">
        <div class="mini-explosion-ring water-ring"></div>
        <div class="mini-explosion-ring water-ring"></div>
        <div class="mini-explosion-particles">
            <div class="mini-particle-spark water-spark"></div>
            <div class="mini-particle-spark water-spark"></div>
            <div class="mini-particle-spark water-spark"></div>
            <div class="mini-particle-spark water-spark"></div>
        </div>
    </div>
}

@* Full-screen explosion animation for game end *@
@if (showFullScreenExplosion)
{
    <div class="fullscreen-explosion-overlay">
        <!-- Multiple explosion rings spreading across the screen -->
        <div class="fullscreen-explosion-ring ring-1"></div>
        <div class="fullscreen-explosion-ring ring-2"></div>
        <div class="fullscreen-explosion-ring ring-3"></div>
        <div class="fullscreen-explosion-ring ring-4"></div>
        <div class="fullscreen-explosion-ring ring-5"></div>
        
        <!-- Explosion particles -->
        <div class="fullscreen-explosion-particles">
            @for (int i = 0; i < 20; i++)
            {
                <div class="fullscreen-particle" style="--particle-delay: @(i * 0.1)s; --particle-angle: @(i * 18)deg;"></div>
            }
        </div>
    </div>
}

<style>
    /* Battle Page Background */
    .battle-container {
        min-height: 100vh;
        position: relative;
        overflow: hidden;
        background: linear-gradient(135deg, #0f3460 0%, #16537e 25%, #2e8b9e 50%, #3ea8a8 75%, #4fc3aa 100%);
        font-family: 'Exo 2', sans-serif;
    }

    /* Animated Background Particles */
    .particles-bg {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
        z-index: 1;
    }

    .particle {
        position: absolute;
        width: 3px;
        height: 3px;
        background: rgba(255, 255, 255, 0.4);
        border-radius: 50%;
        animation: float var(--duration) infinite ease-in-out;
        animation-delay: var(--delay);
        left: calc(var(--delay) * 25);
        top: calc(var(--delay) * 20);
    }

    .battle-content {
        position: relative;
        z-index: 2;
        padding: 2rem;
        min-height: 100vh;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: flex-start;
        padding-top: 2rem;
    }

    h3 {
        color: #ffffff;
        text-align: center;
        margin-bottom: 30px;
        font-size: 2.5rem;
        font-weight: 700;
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        font-family: 'Orbitron', sans-serif;
    }

    .battle-status {
        text-align: center;
        margin: 20px 0;
        padding: 20px;
        background: rgba(255, 255, 255, 0.1);
        backdrop-filter: blur(10px);
        color: white;
        border-radius: 15px;
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
        border: 1px solid rgba(255, 255, 255, 0.2);
        max-width: 600px;
    }

    .status-text {
        font-size: 1.3rem;
        font-weight: 600;
        margin: 0;
        text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
    }

    .boards-container {
        display: flex;
        justify-content: center;
        gap: 40px;
        margin-top: 20px;
        flex-wrap: wrap;
    }

    .board-section {
        display: flex;
        flex-direction: column;
        align-items: center;
    }

    .board-section h3 {
        color: #ffffff;
        margin-top: 15px;
        margin-bottom: 0;
        font-size: 1.5rem;
        font-weight: 700;
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
    }

    .board-label {
        text-align: center;
        margin-top: 20px;
        padding: 20px 30px;
        background: rgba(255, 255, 255, 0.1);
        backdrop-filter: blur(10px);
        color: white;
        border-radius: 20px;
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
        border: 1px solid rgba(255, 255, 255, 0.2);
        max-width: 300px;
        margin-left: auto;
        margin-right: auto;
        transition: all 0.3s ease;
    }

    .board-label.active-turn {
        background: linear-gradient(135deg, #ff6b6b, #ee5a24);
        box-shadow: 0 8px 32px rgba(255, 107, 107, 0.4);
        border: 1px solid rgba(255, 107, 107, 0.3);
    }

    .board-label h3 {
        color: #ffffff;
        margin: 0;
        font-size: 1.6rem;
        font-weight: 700;
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        font-family: 'Orbitron', sans-serif;
    }

    table {
        border-collapse: collapse;
        margin: 0 auto;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        border-radius: 8px;
        overflow: hidden;
        border: 2px solid #333;
    }

    td {
        width: 40px;
        height: 40px;
        border: 1px solid #333;
        text-align: center;
        vertical-align: middle;
        cursor: pointer;
        font-weight: bold;
        font-size: 18px;
        user-select: none;
        transition: all 0.2s ease;
        border-right: 1px solid #333;
        border-bottom: 1px solid #333;
    }

    /* Remove borders on outer edges to work with table border */
    td:first-child {
        border-left: none;
    }

    td:last-child {
        border-right: none;
    }

    tr:first-child td {
        border-top: none;
    }

    tr:last-child td {
        border-bottom: none;
    }

    .empty {
        background-color: #87CEEB;
    }

    .empty:hover {
        background-color: #B0E0E6;
        transform: scale(1.05);
    }

    .ship {
        background-color: #4169E1;
        color: white;
        box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.2);
    }

    .hit {
        background-color: #DC143C;
        color: white;
        position: relative;
        font-weight: bold;
        font-size: 18px;
    }

    .hit::after {
        content: "";
        position: absolute;
        top: 2px;
        right: 2px;
        width: 8px;
        height: 8px;
        background-color: #FF4500;
        border-radius: 50%;
        box-shadow: 0 0 4px rgba(255, 69, 0, 0.6);
    }

    .miss {
        background-color: #696969;
        color: white;
    }

    .hit, .miss {
        cursor: not-allowed;
    }

    .sunk {
        background-color: #8B0000 !important;
        color: white;
        font-weight: bold;
        font-size: 18px;
        cursor: not-allowed;
        box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
    }

    .victory-message {
        text-align: center;
        margin-top: 30px;
        padding: 25px;
        background: rgba(40, 167, 69, 0.2);
        backdrop-filter: blur(10px);
        color: white;
        border-radius: 20px;
        box-shadow: 0 8px 32px rgba(40, 167, 69, 0.3);
        border: 2px solid rgba(40, 167, 69, 0.4);
        max-width: 500px;
        margin-left: auto;
        margin-right: auto;
    }

    .victory-message h2 {
        margin: 0 0 15px 0;
        font-size: 2rem;
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        font-family: 'Orbitron', sans-serif;
    }

    .defeat-message {
        text-align: center;
        margin-top: 30px;
        padding: 25px;
        background: rgba(220, 53, 69, 0.2);
        backdrop-filter: blur(10px);
        color: white;
        border-radius: 20px;
        box-shadow: 0 8px 32px rgba(220, 53, 69, 0.3);
        border: 2px solid rgba(220, 53, 69, 0.4);
        max-width: 500px;
        margin-left: auto;
        margin-right: auto;
    }

    .defeat-message h2 {
        margin: 0 0 15px 0;
        font-size: 2rem;
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        font-family: 'Orbitron', sans-serif;
        color: #ff6b6b;
    }

    .btn {
        padding: 12px 24px;
        border: 2px solid #000;
        border-radius: 8px;
        cursor: pointer;
        font-weight: 600;
        text-decoration: none;
        display: inline-block;
        transition: all 0.3s ease;
    }

    .btn-primary {
        background: linear-gradient(135deg, #ff6b6b, #ee5a24);
        color: white;
        border: 2px solid #000;
        box-shadow: 0 8px 30px rgba(255, 107, 107, 0.3);
    }

    .btn-primary:hover {
        background: linear-gradient(135deg, #ff6b6b, #ee5a24);
        transform: translateY(-3px);
        box-shadow: 0 12px 40px rgba(255, 107, 107, 0.4);
        border: 2px solid #000;
    }

    .btn-orange {
        background: linear-gradient(135deg, #ff8c00, #ff6600);
        color: white;
        border: 2px solid #000;
        box-shadow: 0 8px 30px rgba(255, 140, 0, 0.4);
        font-size: 1.2rem;
        padding: 15px 30px;
        font-weight: bold;
    }

    .btn-orange:hover {
        background: linear-gradient(135deg, #ff7700, #ff5500);
        transform: translateY(-3px);
        box-shadow: 0 12px 40px rgba(255, 140, 0, 0.6);
        border: 2px solid #000;
    }

    .btn-home {
        background: linear-gradient(135deg, #6c757d, #495057);
        color: white;
        border: 2px solid #000;
        box-shadow: 0 8px 30px rgba(108, 117, 125, 0.4);
        font-size: 1.2rem;
        padding: 15px 30px;
        font-weight: bold;
        margin-left: 15px;
    }

    .btn-home:hover {
        background: linear-gradient(135deg, #5a6268, #343a40);
        transform: translateY(-3px);
        box-shadow: 0 12px 40px rgba(108, 117, 125, 0.6);
        border: 2px solid #000;
    }

    .game-result-overlay {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        z-index: 100;
        pointer-events: none;
    }

    .result-text {
        font-size: 4rem;
        font-weight: 900;
        text-transform: uppercase;
        letter-spacing: 4px;
        margin: 0;
        text-shadow: 4px 4px 8px rgba(0, 0, 0, 0.8);
        font-family: 'Orbitron', sans-serif;
        animation: resultTextFadeIn 1s ease-in-out forwards;
        opacity: 0;
    }

    .victory-text {
        color: #00ff00;
        text-shadow: 0 0 30px #00ff00, 4px 4px 8px rgba(0, 0, 0, 0.8);
    }

    .defeat-text {
        color: #ff0000;
        text-shadow: 0 0 30px #ff0000, 4px 4px 8px rgba(0, 0, 0, 0.8);
    }

    @@keyframes resultTextFadeIn {
        0% {
            opacity: 0;
            transform: scale(0.5);
        }
        100% {
            opacity: 1;
            transform: scale(1);
        }
    }

    .game-over-controls {
        text-align: center;
        margin: 30px auto;
        width: 100%;
    }

    .play-again-btn {
        margin: 0 auto;
    }

    .hidden {
        display: none !important;
    }
    
    /* Mini Explosion Effects with Different Sizes */
    .mini-explosion {
        position: fixed;
        pointer-events: none;
        z-index: 1000;
        transform: translate(-50%, -50%);
        /* Ensure explosion stays within viewport */
        max-width: calc(100vw - 20px);
        max-height: calc(100vh - 20px);
    }
    
    /* Different sizes for each explosion */
    .explosion-1 {
        width: 100px;
        height: 100px;
        animation-delay: 0s;
    }
    
    .explosion-2 {
        width: 85px;
        height: 85px;
        animation-delay: 0.5s;
    }
    
    .explosion-3 {
        width: 110px;
        height: 110px;
        animation-delay: 1.0s;
    }
    
    .mini-explosion-ring {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        border-radius: 50%;
    }
    
    /* Fire explosion rings (orange/red) - Largest and most intense */
    .explosion-1 .mini-explosion-ring {
        animation: mini-explode-large 1.2s ease-out forwards;
    }
    
    .fire-ring:nth-child(1) {
        background: radial-gradient(circle, rgba(255, 69, 0, 0.9) 0%, rgba(255, 140, 0, 0.7) 30%, transparent 70%);
        animation-delay: 0s;
    }
    
    .fire-ring:nth-child(2) {
        background: radial-gradient(circle, rgba(255, 215, 0, 0.8) 0%, rgba(255, 69, 0, 0.6) 40%, transparent 70%);
        animation-delay: 0.15s;
    }
    
    /* Transition explosion rings (orange to blue) - Medium size */
    .explosion-2 .mini-explosion-ring {
        animation: mini-explode-medium 1.0s ease-out forwards;
    }
    
    .transition-ring:nth-child(1) {
        background: radial-gradient(circle, rgba(255, 140, 0, 0.8) 0%, rgba(0, 191, 255, 0.6) 50%, transparent 70%);
        animation-delay: 0s;
    }
    
    .transition-ring:nth-child(2) {
        background: radial-gradient(circle, rgba(255, 69, 0, 0.7) 0%, rgba(30, 144, 255, 0.5) 40%, transparent 70%);
        animation-delay: 0.12s;
    }
    
    /* Water/sinking explosion rings (blue/teal) - Largest and longest lasting */
    .explosion-3 .mini-explosion-ring {
        animation: mini-explode-splash 1.4s ease-out forwards;
    }
    
    .water-ring:nth-child(1) {
        background: radial-gradient(circle, rgba(0, 191, 255, 0.8) 0%, rgba(0, 100, 200, 0.6) 30%, transparent 70%);
        animation-delay: 0s;
    }
    
    .water-ring:nth-child(2) {
        background: radial-gradient(circle, rgba(30, 144, 255, 0.7) 0%, rgba(0, 50, 150, 0.5) 40%, transparent 70%);
        animation-delay: 0.18s;
    }
    
    /* Large fire explosion animation */
    @@keyframes mini-explode-large {
        0% {
            width: 0px;
            height: 0px;
            opacity: 1;
        }
        30% {
            width: 120px;
            height: 120px;
            opacity: 0.95;
        }
        70% {
            width: 180px;
            height: 180px;
            opacity: 0.7;
        }
        100% {
            width: 250px;
            height: 250px;
            opacity: 0;
        }
    }
    
    /* Medium transition explosion animation */
    @@keyframes mini-explode-medium {
        0% {
            width: 0px;
            height: 0px;
            opacity: 1;
        }
        40% {
            width: 100px;
            height: 100px;
            opacity: 0.9;
        }
        80% {
            width: 160px;
            height: 160px;
            opacity: 0.6;
        }
        100% {
            width: 200px;
            height: 200px;
            opacity: 0;
        }
    }
    
    /* Large splash/water explosion animation */
    @@keyframes mini-explode-splash {
        0% {
            width: 0px;
            height: 0px;
            opacity: 1;
        }
        25% {
            width: 80px;
            height: 80px;
            opacity: 0.95;
        }
        50% {
            width: 140px;
            height: 140px;
            opacity: 0.85;
        }
        75% {
            width: 200px;
            height: 200px;
            opacity: 0.5;
        }
        100% {
            width: 280px;
            height: 280px;
            opacity: 0;
        }
    }
    
    .mini-explosion-particles {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
    }
    
    .mini-particle-spark {
        position: absolute;
        border-radius: 50%;
    }
    
    /* Fire sparks (yellow/orange) - Large and intense */
    .explosion-1 .mini-particle-spark {
        width: 4px;
        height: 4px;
        animation: mini-spark-large 1.2s ease-out forwards;
    }
    
    .fire-spark {
        background: radial-gradient(circle, #FFD700, #FF6347);
        box-shadow: 0 0 6px #FFD700;
    }
    
    .explosion-1 .fire-spark:nth-child(1) { animation-delay: 0.1s; transform: rotate(0deg) translateX(0px); }
    .explosion-1 .fire-spark:nth-child(2) { animation-delay: 0.15s; transform: rotate(90deg) translateX(0px); }
    .explosion-1 .fire-spark:nth-child(3) { animation-delay: 0.12s; transform: rotate(180deg) translateX(0px); }
    .explosion-1 .fire-spark:nth-child(4) { animation-delay: 0.18s; transform: rotate(270deg) translateX(0px); }
    
    /* Transition sparks (orange to blue) - Medium size */
    .explosion-2 .mini-particle-spark {
        width: 3px;
        height: 3px;
        animation: mini-spark-medium 1.0s ease-out forwards;
    }
    
    .transition-spark {
        background: linear-gradient(45deg, #FF4500, #00BFFF);
        box-shadow: 0 0 4px #FF8C00;
    }
    
    .explosion-2 .transition-spark:nth-child(1) { animation-delay: 0.08s; transform: rotate(45deg) translateX(0px); }
    .explosion-2 .transition-spark:nth-child(2) { animation-delay: 0.12s; transform: rotate(135deg) translateX(0px); }
    .explosion-2 .transition-spark:nth-child(3) { animation-delay: 0.1s; transform: rotate(225deg) translateX(0px); }
    .explosion-2 .transition-spark:nth-child(4) { animation-delay: 0.14s; transform: rotate(315deg) translateX(0px); }
    
    /* Water sparks (blue/teal) - Large and long-lasting */
    .explosion-3 .mini-particle-spark {
        width: 5px;
        height: 5px;
        animation: mini-spark-splash 1.4s ease-out forwards;
    }
    
    .water-spark {
        background: radial-gradient(circle, #00BFFF, #0066CC);
        box-shadow: 0 0 8px #00BFFF;
    }
    
    .explosion-3 .water-spark:nth-child(1) { animation-delay: 0.2s; transform: rotate(30deg) translateX(0px); }
    .explosion-3 .water-spark:nth-child(2) { animation-delay: 0.25s; transform: rotate(120deg) translateX(0px); }
    .explosion-3 .water-spark:nth-child(3) { animation-delay: 0.22s; transform: rotate(210deg) translateX(0px); }
    .explosion-3 .water-spark:nth-child(4) { animation-delay: 0.28s; transform: rotate(300deg) translateX(0px); }
    
    /* Large fire spark animation */
    @@keyframes mini-spark-large {
        0% {
            opacity: 1;
            transform: rotate(var(--angle, 0deg)) translateX(0px) scale(1);
        }
        60% {
            opacity: 0.8;
            transform: rotate(var(--angle, 0deg)) translateX(40px) scale(1.2);
        }
        100% {
            opacity: 0;
            transform: rotate(var(--angle, 0deg)) translateX(60px) scale(0.3);
        }
    }
    
    /* Medium transition spark animation */
    @@keyframes mini-spark-medium {
        0% {
            opacity: 1;
            transform: rotate(var(--angle, 0deg)) translateX(0px) scale(1);
        }
        50% {
            opacity: 0.9;
            transform: rotate(var(--angle, 0deg)) translateX(35px) scale(1.1);
        }
        100% {
            opacity: 0;
            transform: rotate(var(--angle, 0deg)) translateX(50px) scale(0.2);
        }
    }
    
    /* Large splash spark animation */
    @@keyframes mini-spark-splash {
        0% {
            opacity: 1;
            transform: rotate(var(--angle, 0deg)) translateX(0px) scale(1);
        }
        40% {
            opacity: 0.95;
            transform: rotate(var(--angle, 0deg)) translateX(30px) scale(1.3);
        }
        70% {
            opacity: 0.7;
            transform: rotate(var(--angle, 0deg)) translateX(50px) scale(1.1);
        }
        100% {
            opacity: 0;
            transform: rotate(var(--angle, 0deg)) translateX(70px) scale(0.4);
        }
    }

    /* Full-screen explosion styles */
    .fullscreen-explosion-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        background: radial-gradient(circle, rgba(255,255,255,0.8) 0%, rgba(255,100,0,0.6) 20%, rgba(255,0,0,0.4) 40%, rgba(0,0,0,0.9) 100%);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 10000;
        opacity: 0;
        animation: fullscreenExplosionFade 4s ease-in-out forwards;
        pointer-events: none;
    }

    .fullscreen-explosion-ring {
        position: absolute;
        border: 4px solid rgba(255, 165, 0, 0.8);
        border-radius: 50%;
        width: 50px;
        height: 50px;
        top: 50%;
        left: 50%;
        margin-left: -25px;
        margin-top: -25px;
        animation: explosionRingExpand 2.5s ease-out forwards;
    }

    .fullscreen-explosion-ring.ring-1 {
        animation-delay: 0s;
        border-color: rgba(255, 255, 255, 0.9);
    }

    .fullscreen-explosion-ring.ring-2 {
        animation-delay: 0.2s;
        border-color: rgba(255, 200, 0, 0.8);
    }

    .fullscreen-explosion-ring.ring-3 {
        animation-delay: 0.4s;
        border-color: rgba(255, 100, 0, 0.7);
    }

    .fullscreen-explosion-ring.ring-4 {
        animation-delay: 0.6s;
        border-color: rgba(255, 50, 0, 0.6);
    }

    .fullscreen-explosion-ring.ring-5 {
        animation-delay: 0.8s;
        border-color: rgba(200, 0, 0, 0.5);
    }

    .fullscreen-particle {
        position: absolute;
        width: 6px;
        height: 6px;
        background: radial-gradient(circle, #fff 0%, #ff6600 50%, #ff0000 100%);
        border-radius: 50%;
        top: 50%;
        left: 50%;
        margin-left: -3px;
        margin-top: -3px;
        animation: fullscreenParticleMove 3s ease-out forwards;
        opacity: 0;
    }

    .game-result-message {
        text-align: center;
        color: white;
        font-family: 'Arial Black', Arial, sans-serif;
        text-shadow: 3px 3px 6px rgba(0,0,0,0.8);
        z-index: 1;
        opacity: 0;
        animation: gameResultFadeIn 1.5s ease-in-out 2.5s forwards;
    }

    .game-result-message h1 {
        font-size: 4rem;
        margin: 0 0 20px 0;
        text-transform: uppercase;
        letter-spacing: 3px;
    }

    .game-result-message h2 {
        font-size: 2rem;
        margin: 0;
        font-weight: normal;
    }

    .victory-message h1 {
        color: #00ff00;
        text-shadow: 0 0 20px #00ff00, 3px 3px 6px rgba(0,0,0,0.8);
    }

    .defeat-message h1 {
        color: #ff0000;
        text-shadow: 0 0 20px #ff0000, 3px 3px 6px rgba(0,0,0,0.8);
    }

    @@keyframes fullscreenExplosionFade {
        0% {
            opacity: 0;
        }
        10% {
            opacity: 1;
        }
        70% {
            opacity: 1;
        }
        100% {
            opacity: 0;
        }
    }

    @@keyframes explosionRingExpand {
        0% {
            width: 50px;
            height: 50px;
            margin-left: -25px;
            margin-top: -25px;
            opacity: 1;
            border-width: 8px;
        }
        50% {
            width: 80vmin;
            height: 80vmin;
            margin-left: -40vmin;
            margin-top: -40vmin;
            opacity: 0.6;
            border-width: 6px;
        }
        100% {
            width: 120vmin;
            height: 120vmin;
            margin-left: -60vmin;
            margin-top: -60vmin;
            opacity: 0;
            border-width: 2px;
        }
    }

    @@keyframes fullscreenParticleMove {
        0% {
            opacity: 1;
            transform: translate(0, 0) scale(1);
        }
        20% {
            opacity: 1;
            transform: translate(calc(var(--particle-x, 0) * 20px), calc(var(--particle-y, 0) * 20px)) scale(1.2);
        }
        100% {
            opacity: 0;
            transform: translate(calc(var(--particle-x, 0) * 100px), calc(var(--particle-y, 0) * 100px)) scale(0.2);
        }
    }

    @@keyframes gameResultFadeIn {
        0% {
            opacity: 0;
            transform: scale(0.5);
        }
        50% {
            opacity: 1;
            transform: scale(1.1);
        }
        100% {
            opacity: 1;
            transform: scale(1);
        }
    }

    /* Mobile Responsive Design */
    @@media (max-width: 768px) {
        .battle-content {
            padding: 1rem;
            padding-top: 2rem;
        }

        h3 {
            font-size: 1.8rem;
            margin-bottom: 20px;
        }

        .boards-container {
            flex-direction: column;
            gap: 20px;
            margin-top: 15px;
        }

        .board-section table {
            width: 320px;
            height: 320px;
            margin: 10px auto;
        }

        .board-section td {
            width: 32px;
            height: 32px;
            font-size: 14px;
            /* Improve touch targets for gameplay */
            min-height: 44px;
            min-width: 44px;
        }

        .board-section h3 {
            font-size: 1.3rem;
            margin-top: 10px;
        }

        .board-label h3 {
            font-size: 1.2rem;
        }

        .game-over-controls {
            margin: 20px auto;
        }

        .play-again-btn, .home-btn {
            padding: 12px 24px;
            font-size: 14px;
            margin: 8px;
            min-height: 48px;
        }

        .result-text {
            font-size: 2.5rem;
        }
    }

    @@media (max-width: 480px) {
        .battle-content {
            padding: 0.5rem;
            padding-top: 1rem;
        }

        h3 {
            font-size: 1.5rem;
        }

        .boards-container {
            gap: 15px;
        }

        .board-section table {
            width: 280px;
            height: 280px;
        }

        .board-section td {
            width: 28px;
            height: 28px;
            font-size: 12px;
        }

        .board-section h3 {
            font-size: 1.1rem;
        }

        .board-label h3 {
            font-size: 1rem;
        }

        .result-text {
            font-size: 2rem;
        }

        .play-again-btn, .home-btn {
            padding: 8px 16px;
            font-size: 13px;
        }
    }
</style>

@code {
    public class ExplosionEffect
    {
        public int Row { get; set; }
        public int Col { get; set; }
        public bool IsOpponentGrid { get; set; }
        public Guid Id { get; set; } = Guid.NewGuid();
    }

    // 0 = empty, 1 = ship, 2 = hit, 3 = miss
    int[,] opponentGrid = new int[10, 10];
    ShipManager shipManager = new ShipManager();
    private int totalOpponentShips = 0;
    private int hitOpponentShips = 0;
    private bool isPlayerTurn; // Will be randomly determined
    
    // Track opponent ships for sunk detection
    private List<OpponentShip> opponentShips = new List<OpponentShip>();
    
    // Track sunk player ships
    private List<Ship> sunkPlayerShips = new List<Ship>();
    
    // Explosion effects - Support multiple simultaneous explosions
    private List<ExplosionEffect> activeExplosions = new List<ExplosionEffect>();
    
    // AI Strategy Variables
    private List<(int row, int col)> targetStack = new List<(int, int)>(); // Cells to investigate after a hit
    private (int row, int col)? lastHit = null; // Last successful hit
    private (int row, int col)? firstHit = null; // First hit of current ship
    private List<(int row, int col)> currentShipHits = new List<(int, int)>(); // All hits on current ship being hunted
    private bool huntingMode = false; // Whether we're hunting a specific ship
    
    // Screen shake effect
    private bool isShaking = false;
    
    // Full-screen explosion for game end
    private bool showFullScreenExplosion = false;
    private string gameResult = ""; // "victory" or "defeat"
    
    public class OpponentShip
    {
        public string Type { get; set; }
        public List<(int row, int col)> Coordinates { get; set; }
        public bool IsSunk { get; set; } = false;
        
        public OpponentShip(string type, List<(int row, int col)> coordinates)
        {
            Type = type;
            Coordinates = coordinates;
        }
        
        public bool CheckIfSunk(int[,] grid)
        {
            return Coordinates.All(coord => grid[coord.row, coord.col] == 2);
        }
    }

    protected override void OnInitialized()
    {
        // Randomly determine who goes first
        isPlayerTurn = Random.Shared.Next(2) == 0; // 50% chance for player to go first
        
        // Check if we have player ships from the ship placement page
        if (GameState.HasPlayerShips())
        {
            // Use the ships from the ship placement page
            shipManager = GameState.PlayerShipManager!;
        }
        else
        {
            // If no ships are configured, redirect back to ship placement
            Navigation.NavigateTo("/ship-placement");
            return;
        }
        
        PlaceOpponentShips();
        
        // If it's opponent's turn first, make their move after a short delay
        if (!isPlayerTurn)
        {
            Task.Delay(1000).ContinueWith(_ => InvokeAsync(() => {
                SimulateOpponentTurn();
            }));
        }
    }

    void PlaceOpponentShips()
    {
        // Create a ShipManager for the opponent to use the same logic
        var opponentShipManager = new ShipManager();
        var random = new Random();
        int maxAttempts = 1000; // Prevent infinite loops
        
        // Try to place each ship randomly
        foreach (var ship in opponentShipManager.Ships)
        {
            bool placed = false;
            int attempts = 0;
            
            while (!placed && attempts < maxAttempts)
            {
                // Random position and orientation
                int row = random.Next(0, 10);
                int col = random.Next(0, 10);
                var orientation = random.Next(0, 2) == 0 ? ShipOrientation.Horizontal : ShipOrientation.Vertical;
                
                // Try to place the ship
                if (opponentShipManager.CanPlaceShip(ship, row, col, orientation))
                {
                    opponentShipManager.PlaceShip(ship, row, col, orientation);
                    placed = true;
                }
                attempts++;
            }
            
            if (!placed)
            {
                // Fallback: try to place ship in any valid position
                placed = TryPlaceShipAnywhere(opponentShipManager, ship);
                if (!placed)
                {
                    throw new InvalidOperationException($"Could not place {ship.Type} after {maxAttempts} attempts");
                }
            }
        }
        
        // Convert the placed ships to our opponent tracking system
        opponentShips.Clear();
        totalOpponentShips = 0;
        
        foreach (var ship in opponentShipManager.Ships)
        {
            if (ship.IsPlaced)
            {
                var shipCoords = new List<(int row, int col)>();
                
                // Copy ship positions to opponent grid and tracking
                foreach (var (row, col) in ship.Coordinates)
                {
                    opponentGrid[row, col] = 1;
                    shipCoords.Add((row, col));
                    totalOpponentShips++;
                }
                
                opponentShips.Add(new OpponentShip(ship.Type, shipCoords));
            }
        }
    }
    
    bool TryPlaceShipAnywhere(ShipManager manager, Ship ship)
    {
        // Systematically try every position and orientation
        for (int row = 0; row < 10; row++)
        {
            for (int col = 0; col < 10; col++)
            {
                foreach (var orientation in new[] { ShipOrientation.Horizontal, ShipOrientation.Vertical })
                {
                    if (manager.CanPlaceShip(ship, row, col, orientation))
                    {
                        manager.PlaceShip(ship, row, col, orientation);
                        return true;
                    }
                }
            }
        }
        return false;
    }

    void OnOpponentCellClick(int row, int col)
    {
        if (!isPlayerTurn) return; // Not player's turn
        if (row < 0 || row >= 10 || col < 0 || col >= 10)
            return;
        if (opponentGrid[row, col] == 2 || opponentGrid[row, col] == 3)
            return;

        if (opponentGrid[row, col] == 1)
        {
            opponentGrid[row, col] = 2; // hit
            hitOpponentShips++;
            
            // Check if any ships are now sunk
            foreach (var ship in opponentShips)
            {
                if (!ship.IsSunk && ship.CheckIfSunk(opponentGrid))
                {
                    ship.IsSunk = true;
                    // Trigger explosion when opponent ship is sunk at the ship's center
                    var centerCoord = GetShipCenter(ship.Coordinates);
                    TriggerExplosion(centerCoord.row, centerCoord.col, true);
                }
            }
        }
        else
        {
            opponentGrid[row, col] = 3; // miss
        }

        // Switch to opponent's turn after any move (hit or miss)
        isPlayerTurn = false;
        
        // Simulate opponent's turn after a short delay
        _ = Task.Delay(1000).ContinueWith(t => {
            InvokeAsync(() => {
                SimulateOpponentTurn();
                isPlayerTurn = true; // Back to player's turn
                StateHasChanged();
            });
        });

        StateHasChanged();
    }

    void SimulateOpponentTurn()
    {
        (int row, int col) target = GetSmartTarget();
        
        // Attack the selected target
        if (shipManager.Grid[target.row, target.col] == 1)
        {
            // Hit!
            shipManager.Grid[target.row, target.col] = 2;
            currentShipHits.Add(target);
            lastHit = target;
            
            if (firstHit == null)
            {
                firstHit = target;
            }
            
            huntingMode = true;
            
            // Add adjacent cells to target stack for investigation
            AddAdjacentTargets(target.row, target.col);
            
            // Check if we've sunk a ship
            CheckIfShipSunk(target);
        }
        else
        {
            // Miss
            shipManager.Grid[target.row, target.col] = 3;
        }
        
        // Switch turn back to player after opponent's move
        isPlayerTurn = true;
        StateHasChanged();
    }
    
    (int row, int col) GetSmartTarget()
    {
        Random random = new Random();
        
        // If we have targets to investigate (hunting mode), prioritize them
        if (targetStack.Count > 0)
        {
            var target = targetStack[0];
            targetStack.RemoveAt(0);
            
            // Make sure this target is still valid
            if (IsValidTarget(target.row, target.col))
            {
                return target;
            }
            else
            {
                // Target is no longer valid, try the next one
                return GetSmartTarget();
            }
        }
        
        // If not hunting, use random targeting with some strategy
        // Prefer a checkerboard pattern for more efficient searching
        var validTargets = new List<(int row, int col)>();
        
        for (int row = 0; row < 10; row++)
        {
            for (int col = 0; col < 10; col++)
            {
                if (IsValidTarget(row, col))
                {
                    // Prefer checkerboard pattern (since ships are at least 2 cells, this is more efficient)
                    if ((row + col) % 2 == 0)
                    {
                        validTargets.Add((row, col));
                    }
                }
            }
        }
        
        // If no checkerboard targets, add all valid targets
        if (validTargets.Count == 0)
        {
            for (int row = 0; row < 10; row++)
            {
                for (int col = 0; col < 10; col++)
                {
                    if (IsValidTarget(row, col))
                    {
                        validTargets.Add((row, col));
                    }
                }
            }
        }
        
        if (validTargets.Count > 0)
        {
            return validTargets[random.Next(validTargets.Count)];
        }
        
        // Fallback: find any valid target
        for (int row = 0; row < 10; row++)
        {
            for (int col = 0; col < 10; col++)
            {
                if (IsValidTarget(row, col))
                {
                    return (row, col);
                }
            }
        }
        
        // Should never reach here in a normal game
        return (0, 0);
    }
    
    bool IsValidTarget(int row, int col)
    {
        return row >= 0 && row < 10 && col >= 0 && col < 10 && 
               shipManager.Grid[row, col] != 2 && shipManager.Grid[row, col] != 3;
    }
    
    void AddAdjacentTargets(int row, int col)
    {
        // Add adjacent cells (up, down, left, right) to target stack
        var directions = new[] { (-1, 0), (1, 0), (0, -1), (0, 1) };
        
        foreach (var (dr, dc) in directions)
        {
            int newRow = row + dr;
            int newCol = col + dc;
            
            if (IsValidTarget(newRow, newCol) && !targetStack.Contains((newRow, newCol)))
            {
                // If we have multiple hits, prioritize continuing in the same direction
                if (currentShipHits.Count > 1)
                {
                    if (IsInLineWithPreviousHits(newRow, newCol))
                    {
                        targetStack.Insert(0, (newRow, newCol)); // High priority
                    }
                    else
                    {
                        targetStack.Add((newRow, newCol)); // Normal priority
                    }
                }
                else
                {
                    targetStack.Add((newRow, newCol));
                }
            }
        }
    }
    
    bool IsInLineWithPreviousHits(int row, int col)
    {
        if (currentShipHits.Count < 2) return false;
        
        // Check if this position continues the line of previous hits
        var sortedHits = currentShipHits.OrderBy(h => h.row).ThenBy(h => h.col).ToList();
        
        // Check if hits are horizontal
        if (sortedHits.All(h => h.row == sortedHits[0].row))
        {
            return row == sortedHits[0].row && 
                   (col == sortedHits.Min(h => h.col) - 1 || col == sortedHits.Max(h => h.col) + 1);
        }
        
        // Check if hits are vertical
        if (sortedHits.All(h => h.col == sortedHits[0].col))
        {
            return col == sortedHits[0].col && 
                   (row == sortedHits.Min(h => h.row) - 1 || row == sortedHits.Max(h => h.row) + 1);
        }
        
        return false;
    }
    
    void CheckIfShipSunk((int row, int col) hitPosition)
    {
        // Check if the ship at this position has been completely sunk
        var playerShip = shipManager.GetShipAtPosition(hitPosition.row, hitPosition.col);
        if (playerShip != null)
        {
            bool shipSunk = playerShip.Coordinates.All(coord => 
                shipManager.Grid[coord.row, coord.col] == 2);
            
            if (shipSunk)
            {
                // Mark the player ship as sunk
                if (!sunkPlayerShips.Contains(playerShip))
                {
                    sunkPlayerShips.Add(playerShip);
                    // Trigger explosion when player ship is sunk at the ship's center
                    var centerCoord = GetShipCenter(playerShip.Coordinates);
                    TriggerExplosion(centerCoord.row, centerCoord.col, false);
                }
                
                // Ship is sunk, reset hunting mode
                huntingMode = false;
                targetStack.Clear();
                firstHit = null;
                lastHit = null;
                currentShipHits.Clear();
            }
        }
    }

    bool CheckVictory()
    {
        bool victory = hitOpponentShips >= totalOpponentShips;
        if (victory && !showFullScreenExplosion && gameResult != "victory")
        {
            TriggerFullScreenExplosion("victory");
        }
        return victory;
    }

    bool CheckDefeat()
    {
        // Get the total number of ships that should be placed
        int totalPlayerShips = GameState.PlayerShipManager?.Ships?.Count ?? 5; // Default to 5 ships
        bool defeat = sunkPlayerShips.Count >= totalPlayerShips;
        if (defeat && !showFullScreenExplosion && gameResult != "defeat")
        {
            TriggerFullScreenExplosion("defeat");
        }
        return defeat;
    }

    void TriggerFullScreenExplosion(string result)
    {
        gameResult = result;
        showFullScreenExplosion = true;
        StateHasChanged();
        
        // Hide the explosion overlay after the animation completes (4 seconds)
        Task.Delay(4000).ContinueWith(_ =>
        {
            InvokeAsync(() =>
            {
                showFullScreenExplosion = false;
                StateHasChanged();
            });
        });
    }

    void RestartGame()
    {
        // Clear game state and redirect to ship placement
        sunkPlayerShips.Clear();
        activeExplosions.Clear();
        showFullScreenExplosion = false;
        gameResult = "";
        GameState.ClearGameState();
        Navigation.NavigateTo("/ship-placement");
    }
    
    void TriggerExplosion(int row, int col, bool isOpponentGrid)
    {
        // Create a new explosion effect
        var explosion = new ExplosionEffect
        {
            Row = row,
            Col = col,
            IsOpponentGrid = isOpponentGrid
        };
        
        activeExplosions.Add(explosion);
        StateHasChanged();
        
        // Remove this specific explosion after all 3 enhanced explosions complete (3 seconds)
        _ = Task.Delay(3000).ContinueWith(t => {
            InvokeAsync(() => {
                activeExplosions.RemoveAll(e => e.Id == explosion.Id);
                StateHasChanged();
            });
        });
    }
    
    (int row, int col) GetShipCenter(List<(int row, int col)> coordinates)
    {
        // Calculate the center point of the ship
        var avgRow = coordinates.Average(c => c.row);
        var avgCol = coordinates.Average(c => c.col);
        return ((int)Math.Round(avgRow), (int)Math.Round(avgCol));
    }
    
    double GetExplosionTop(ExplosionEffect explosion)
    {
        // Calculate percentage position based on grid coordinates
        // The grids are positioned roughly 25% from the top of the viewport
        double baseTopPercent = 25.0;
        double gridHeightPercent = 40.0; // Grid takes up about 40% of viewport height
        double cellPercent = gridHeightPercent / 10.0; // Each cell is 1/10th of grid height
        
        double topPercent = baseTopPercent + (explosion.Row * cellPercent);
        
        // Clamp to viewport bounds (10% margin from edges)
        return Math.Max(10.0, Math.Min(90.0, topPercent));
    }
    
    double GetExplosionLeft(ExplosionEffect explosion)
    {
        // Calculate percentage position based on grid coordinates
        double cellPercent = 4.0; // Each cell is roughly 4% of viewport width
        
        double leftPercent;
        if (explosion.IsOpponentGrid)
        {
            // Opponent grid (right side) - starts around 55% from left
            leftPercent = 55.0 + (explosion.Col * cellPercent);
        }
        else
        {
            // Player grid (left side) - starts around 15% from left  
            leftPercent = 15.0 + (explosion.Col * cellPercent);
        }
        
        // Clamp to viewport bounds (10% margin from edges)
        return Math.Max(10.0, Math.Min(90.0, leftPercent));
    }

    string GetPlayerCellClass(int row, int col)
    {
        return shipManager.Grid[row, col] switch
        {
            2 => GetPlayerHitCellClass(row, col), // Ship hit by opponent - check if sunk
            3 => "miss",   // Empty cell hit by opponent (miss)
            1 => "ship",   // Undamaged ship
            _ => "empty"   // Empty, not attacked
        };
    }
    
    string GetPlayerHitCellClass(int row, int col)
    {
        // Check if this position belongs to a sunk player ship
        var playerShip = shipManager.GetShipAtPosition(row, col);
        if (playerShip != null && sunkPlayerShips.Contains(playerShip))
        {
            return "sunk"; // Sunk player ship
        }
        
        return "hit"; // Regular hit
    }

    string GetOpponentCellClass(int row, int col)
    {
        if (opponentGrid[row, col] == 2) // hit
        {
            // Check if this position belongs to a sunk ship
            var sunkShip = opponentShips.FirstOrDefault(ship => 
                ship.IsSunk && ship.Coordinates.Contains((row, col)));
            
            if (sunkShip != null)
            {
                return "sunk"; // Sunk ship
            }
            
            return "hit"; // Regular hit
        }
        else if (opponentGrid[row, col] == 3) // miss
        {
            return "miss";
        }
        
        return "empty"; // Empty or undamaged ship
    }

    string DisplayPlayerCellContent(int row, int col)
    {
        int cellValue = shipManager.Grid[row, col];
        
        if (cellValue == 2) // Hit ship
        {
            var ship = shipManager.GetShipAtPosition(row, col);
            if (ship != null)
            {
                return ship.Type[0].ToString(); // First letter of ship type
            }
            return "X"; // Fallback if ship not found
        }
        else if (cellValue == 3) // Miss
        {
            return "O";
        }
        else if (cellValue == 1) // Undamaged ship
        {
            var ship = shipManager.GetShipAtPosition(row, col);
            if (ship != null)
            {
                return ship.Type[0].ToString(); // First letter of ship type
            }
        }
        
        return ""; // Empty cell
    }

    string DisplayCellContent(int[,] grid, int row, int col)
    {
        if (grid[row, col] == 2) // hit
        {
            // Check if this position belongs to a sunk ship
            var sunkShip = opponentShips.FirstOrDefault(ship => 
                ship.IsSunk && ship.Coordinates.Contains((row, col)));
            
            if (sunkShip != null)
            {
                return sunkShip.Type[0].ToString(); // First letter of ship type
            }
            
            return "X"; // Regular hit
        }
        else if (grid[row, col] == 3) // miss
        {
            return "O";
        }
        
        return ""; // Empty or undamaged ship
    }
    
    void NavigateToHome()
    {
        Navigation.NavigateTo("/");
    }
}
